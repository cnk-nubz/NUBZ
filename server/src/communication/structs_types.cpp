/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "structs_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace communication {


InternalError::~InternalError() throw() {
}


uint32_t InternalError::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InternalError::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InternalError");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InternalError &a, InternalError &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

InternalError::InternalError(const InternalError& other0) : TException() {
  (void) other0;
}
InternalError& InternalError::operator=(const InternalError& other1) {
  (void) other1;
  return *this;
}
void InternalError::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InternalError(";
  out << ")";
}

const char* InternalError::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InternalError";
  }
}


InvalidData::~InvalidData() throw() {
}


uint32_t InvalidData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InvalidData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InvalidData");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InvalidData &a, InvalidData &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

InvalidData::InvalidData(const InvalidData& other2) : TException() {
  (void) other2;
}
InvalidData& InvalidData::operator=(const InvalidData& other3) {
  (void) other3;
  return *this;
}
void InvalidData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InvalidData(";
  out << ")";
}

const char* InvalidData::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: InvalidData";
  }
}


HelloMsg::~HelloMsg() throw() {
}


void HelloMsg::__set_num(const int32_t val) {
  this->num = val;
}

void HelloMsg::__set_msg(const std::string& val) {
  this->msg = val;
}

uint32_t HelloMsg::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num);
          this->__isset.num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HelloMsg::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HelloMsg");

  xfer += oprot->writeFieldBegin("num", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HelloMsg &a, HelloMsg &b) {
  using ::std::swap;
  swap(a.num, b.num);
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

HelloMsg::HelloMsg(const HelloMsg& other4) {
  num = other4.num;
  msg = other4.msg;
  __isset = other4.__isset;
}
HelloMsg& HelloMsg::operator=(const HelloMsg& other5) {
  num = other5.num;
  msg = other5.msg;
  __isset = other5.__isset;
  return *this;
}
void HelloMsg::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HelloMsg(";
  out << "num=" << to_string(num);
  out << ", " << "msg=" << to_string(msg);
  out << ")";
}


MapImagesRequest::~MapImagesRequest() throw() {
}


void MapImagesRequest::__set_acquiredVersion(const int32_t val) {
  this->acquiredVersion = val;
__isset.acquiredVersion = true;
}

uint32_t MapImagesRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->acquiredVersion);
          this->__isset.acquiredVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MapImagesRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MapImagesRequest");

  if (this->__isset.acquiredVersion) {
    xfer += oprot->writeFieldBegin("acquiredVersion", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->acquiredVersion);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MapImagesRequest &a, MapImagesRequest &b) {
  using ::std::swap;
  swap(a.acquiredVersion, b.acquiredVersion);
  swap(a.__isset, b.__isset);
}

MapImagesRequest::MapImagesRequest(const MapImagesRequest& other6) {
  acquiredVersion = other6.acquiredVersion;
  __isset = other6.__isset;
}
MapImagesRequest& MapImagesRequest::operator=(const MapImagesRequest& other7) {
  acquiredVersion = other7.acquiredVersion;
  __isset = other7.__isset;
  return *this;
}
void MapImagesRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MapImagesRequest(";
  out << "acquiredVersion="; (__isset.acquiredVersion ? (out << to_string(acquiredVersion)) : (out << "<null>"));
  out << ")";
}


MapImagesResponse::~MapImagesResponse() throw() {
}


void MapImagesResponse::__set_version(const int32_t val) {
  this->version = val;
}

void MapImagesResponse::__set_levelImageUrls(const std::map<int32_t, std::string> & val) {
  this->levelImageUrls = val;
}

uint32_t MapImagesResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->levelImageUrls.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _ktype9;
            ::apache::thrift::protocol::TType _vtype10;
            xfer += iprot->readMapBegin(_ktype9, _vtype10, _size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              int32_t _key13;
              xfer += iprot->readI32(_key13);
              std::string& _val14 = this->levelImageUrls[_key13];
              xfer += iprot->readString(_val14);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.levelImageUrls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MapImagesResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MapImagesResponse");

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("levelImageUrls", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->levelImageUrls.size()));
    std::map<int32_t, std::string> ::const_iterator _iter15;
    for (_iter15 = this->levelImageUrls.begin(); _iter15 != this->levelImageUrls.end(); ++_iter15)
    {
      xfer += oprot->writeI32(_iter15->first);
      xfer += oprot->writeString(_iter15->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MapImagesResponse &a, MapImagesResponse &b) {
  using ::std::swap;
  swap(a.version, b.version);
  swap(a.levelImageUrls, b.levelImageUrls);
  swap(a.__isset, b.__isset);
}

MapImagesResponse::MapImagesResponse(const MapImagesResponse& other16) {
  version = other16.version;
  levelImageUrls = other16.levelImageUrls;
  __isset = other16.__isset;
}
MapImagesResponse& MapImagesResponse::operator=(const MapImagesResponse& other17) {
  version = other17.version;
  levelImageUrls = other17.levelImageUrls;
  __isset = other17.__isset;
  return *this;
}
void MapImagesResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MapImagesResponse(";
  out << "version=" << to_string(version);
  out << ", " << "levelImageUrls=" << to_string(levelImageUrls);
  out << ")";
}


MapImageTilesRequest::~MapImageTilesRequest() throw() {
}


void MapImageTilesRequest::__set_floor(const int32_t val) {
  this->floor = val;
}

uint32_t MapImageTilesRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->floor);
          this->__isset.floor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MapImageTilesRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MapImageTilesRequest");

  xfer += oprot->writeFieldBegin("floor", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->floor);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MapImageTilesRequest &a, MapImageTilesRequest &b) {
  using ::std::swap;
  swap(a.floor, b.floor);
  swap(a.__isset, b.__isset);
}

MapImageTilesRequest::MapImageTilesRequest(const MapImageTilesRequest& other18) {
  floor = other18.floor;
  __isset = other18.__isset;
}
MapImageTilesRequest& MapImageTilesRequest::operator=(const MapImageTilesRequest& other19) {
  floor = other19.floor;
  __isset = other19.__isset;
  return *this;
}
void MapImageTilesRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MapImageTilesRequest(";
  out << "floor=" << to_string(floor);
  out << ")";
}


Size::~Size() throw() {
}


void Size::__set_width(const int32_t val) {
  this->width = val;
}

void Size::__set_height(const int32_t val) {
  this->height = val;
}

uint32_t Size::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->width);
          this->__isset.width = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->height);
          this->__isset.height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Size::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Size");

  xfer += oprot->writeFieldBegin("width", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->width);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("height", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->height);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Size &a, Size &b) {
  using ::std::swap;
  swap(a.width, b.width);
  swap(a.height, b.height);
  swap(a.__isset, b.__isset);
}

Size::Size(const Size& other20) {
  width = other20.width;
  height = other20.height;
  __isset = other20.__isset;
}
Size& Size::operator=(const Size& other21) {
  width = other21.width;
  height = other21.height;
  __isset = other21.__isset;
  return *this;
}
void Size::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Size(";
  out << "width=" << to_string(width);
  out << ", " << "height=" << to_string(height);
  out << ")";
}


ImageTiles::~ImageTiles() throw() {
}


void ImageTiles::__set_scaledSize(const Size& val) {
  this->scaledSize = val;
}

void ImageTiles::__set_tileSize(const Size& val) {
  this->tileSize = val;
}

void ImageTiles::__set_tilesUrls(const std::vector<std::vector<std::string> > & val) {
  this->tilesUrls = val;
}

uint32_t ImageTiles::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->scaledSize.read(iprot);
          this->__isset.scaledSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tileSize.read(iprot);
          this->__isset.tileSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tilesUrls.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _etype25;
            xfer += iprot->readListBegin(_etype25, _size22);
            this->tilesUrls.resize(_size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              {
                this->tilesUrls[_i26].clear();
                uint32_t _size27;
                ::apache::thrift::protocol::TType _etype30;
                xfer += iprot->readListBegin(_etype30, _size27);
                this->tilesUrls[_i26].resize(_size27);
                uint32_t _i31;
                for (_i31 = 0; _i31 < _size27; ++_i31)
                {
                  xfer += iprot->readString(this->tilesUrls[_i26][_i31]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tilesUrls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ImageTiles::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ImageTiles");

  xfer += oprot->writeFieldBegin("scaledSize", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->scaledSize.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tileSize", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->tileSize.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tilesUrls", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->tilesUrls.size()));
    std::vector<std::vector<std::string> > ::const_iterator _iter32;
    for (_iter32 = this->tilesUrls.begin(); _iter32 != this->tilesUrls.end(); ++_iter32)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter32).size()));
        std::vector<std::string> ::const_iterator _iter33;
        for (_iter33 = (*_iter32).begin(); _iter33 != (*_iter32).end(); ++_iter33)
        {
          xfer += oprot->writeString((*_iter33));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ImageTiles &a, ImageTiles &b) {
  using ::std::swap;
  swap(a.scaledSize, b.scaledSize);
  swap(a.tileSize, b.tileSize);
  swap(a.tilesUrls, b.tilesUrls);
  swap(a.__isset, b.__isset);
}

ImageTiles::ImageTiles(const ImageTiles& other34) {
  scaledSize = other34.scaledSize;
  tileSize = other34.tileSize;
  tilesUrls = other34.tilesUrls;
  __isset = other34.__isset;
}
ImageTiles& ImageTiles::operator=(const ImageTiles& other35) {
  scaledSize = other35.scaledSize;
  tileSize = other35.tileSize;
  tilesUrls = other35.tilesUrls;
  __isset = other35.__isset;
  return *this;
}
void ImageTiles::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ImageTiles(";
  out << "scaledSize=" << to_string(scaledSize);
  out << ", " << "tileSize=" << to_string(tileSize);
  out << ", " << "tilesUrls=" << to_string(tilesUrls);
  out << ")";
}


MapImageTilesResponse::~MapImageTilesResponse() throw() {
}


void MapImageTilesResponse::__set_originalSize(const Size& val) {
  this->originalSize = val;
}

void MapImageTilesResponse::__set_zoomLevels(const std::vector<ImageTiles> & val) {
  this->zoomLevels = val;
}

uint32_t MapImageTilesResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->originalSize.read(iprot);
          this->__isset.originalSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->zoomLevels.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _etype39;
            xfer += iprot->readListBegin(_etype39, _size36);
            this->zoomLevels.resize(_size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              xfer += this->zoomLevels[_i40].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.zoomLevels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MapImageTilesResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MapImageTilesResponse");

  xfer += oprot->writeFieldBegin("originalSize", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->originalSize.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("zoomLevels", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->zoomLevels.size()));
    std::vector<ImageTiles> ::const_iterator _iter41;
    for (_iter41 = this->zoomLevels.begin(); _iter41 != this->zoomLevels.end(); ++_iter41)
    {
      xfer += (*_iter41).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MapImageTilesResponse &a, MapImageTilesResponse &b) {
  using ::std::swap;
  swap(a.originalSize, b.originalSize);
  swap(a.zoomLevels, b.zoomLevels);
  swap(a.__isset, b.__isset);
}

MapImageTilesResponse::MapImageTilesResponse(const MapImageTilesResponse& other42) {
  originalSize = other42.originalSize;
  zoomLevels = other42.zoomLevels;
  __isset = other42.__isset;
}
MapImageTilesResponse& MapImageTilesResponse::operator=(const MapImageTilesResponse& other43) {
  originalSize = other43.originalSize;
  zoomLevels = other43.zoomLevels;
  __isset = other43.__isset;
  return *this;
}
void MapImageTilesResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MapImageTilesResponse(";
  out << "originalSize=" << to_string(originalSize);
  out << ", " << "zoomLevels=" << to_string(zoomLevels);
  out << ")";
}


SetMapImageRequest::~SetMapImageRequest() throw() {
}


void SetMapImageRequest::__set_level(const int32_t val) {
  this->level = val;
}

void SetMapImageRequest::__set_filename(const std::string& val) {
  this->filename = val;
}

uint32_t SetMapImageRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->level);
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->filename);
          this->__isset.filename = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SetMapImageRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SetMapImageRequest");

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filename", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->filename);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SetMapImageRequest &a, SetMapImageRequest &b) {
  using ::std::swap;
  swap(a.level, b.level);
  swap(a.filename, b.filename);
  swap(a.__isset, b.__isset);
}

SetMapImageRequest::SetMapImageRequest(const SetMapImageRequest& other44) {
  level = other44.level;
  filename = other44.filename;
  __isset = other44.__isset;
}
SetMapImageRequest& SetMapImageRequest::operator=(const SetMapImageRequest& other45) {
  level = other45.level;
  filename = other45.filename;
  __isset = other45.__isset;
  return *this;
}
void SetMapImageRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SetMapImageRequest(";
  out << "level=" << to_string(level);
  out << ", " << "filename=" << to_string(filename);
  out << ")";
}


ExhibitsRequest::~ExhibitsRequest() throw() {
}


void ExhibitsRequest::__set_acquiredVersion(const int32_t val) {
  this->acquiredVersion = val;
__isset.acquiredVersion = true;
}

uint32_t ExhibitsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->acquiredVersion);
          this->__isset.acquiredVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ExhibitsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ExhibitsRequest");

  if (this->__isset.acquiredVersion) {
    xfer += oprot->writeFieldBegin("acquiredVersion", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->acquiredVersion);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ExhibitsRequest &a, ExhibitsRequest &b) {
  using ::std::swap;
  swap(a.acquiredVersion, b.acquiredVersion);
  swap(a.__isset, b.__isset);
}

ExhibitsRequest::ExhibitsRequest(const ExhibitsRequest& other46) {
  acquiredVersion = other46.acquiredVersion;
  __isset = other46.__isset;
}
ExhibitsRequest& ExhibitsRequest::operator=(const ExhibitsRequest& other47) {
  acquiredVersion = other47.acquiredVersion;
  __isset = other47.__isset;
  return *this;
}
void ExhibitsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ExhibitsRequest(";
  out << "acquiredVersion="; (__isset.acquiredVersion ? (out << to_string(acquiredVersion)) : (out << "<null>"));
  out << ")";
}


MapElementFrame::~MapElementFrame() throw() {
}


void MapElementFrame::__set_x(const int32_t val) {
  this->x = val;
}

void MapElementFrame::__set_y(const int32_t val) {
  this->y = val;
}

void MapElementFrame::__set_width(const int32_t val) {
  this->width = val;
}

void MapElementFrame::__set_height(const int32_t val) {
  this->height = val;
}

void MapElementFrame::__set_mapLevel(const int32_t val) {
  this->mapLevel = val;
}

uint32_t MapElementFrame::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->width);
          this->__isset.width = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->height);
          this->__isset.height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mapLevel);
          this->__isset.mapLevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MapElementFrame::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MapElementFrame");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("width", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->width);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("height", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->height);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mapLevel", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->mapLevel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MapElementFrame &a, MapElementFrame &b) {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.width, b.width);
  swap(a.height, b.height);
  swap(a.mapLevel, b.mapLevel);
  swap(a.__isset, b.__isset);
}

MapElementFrame::MapElementFrame(const MapElementFrame& other48) {
  x = other48.x;
  y = other48.y;
  width = other48.width;
  height = other48.height;
  mapLevel = other48.mapLevel;
  __isset = other48.__isset;
}
MapElementFrame& MapElementFrame::operator=(const MapElementFrame& other49) {
  x = other49.x;
  y = other49.y;
  width = other49.width;
  height = other49.height;
  mapLevel = other49.mapLevel;
  __isset = other49.__isset;
  return *this;
}
void MapElementFrame::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MapElementFrame(";
  out << "x=" << to_string(x);
  out << ", " << "y=" << to_string(y);
  out << ", " << "width=" << to_string(width);
  out << ", " << "height=" << to_string(height);
  out << ", " << "mapLevel=" << to_string(mapLevel);
  out << ")";
}


Exhibit::~Exhibit() throw() {
}


void Exhibit::__set_name(const std::string& val) {
  this->name = val;
}

void Exhibit::__set_frame(const MapElementFrame& val) {
  this->frame = val;
__isset.frame = true;
}

uint32_t Exhibit::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->frame.read(iprot);
          this->__isset.frame = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Exhibit::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Exhibit");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.frame) {
    xfer += oprot->writeFieldBegin("frame", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->frame.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Exhibit &a, Exhibit &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.frame, b.frame);
  swap(a.__isset, b.__isset);
}

Exhibit::Exhibit(const Exhibit& other50) {
  name = other50.name;
  frame = other50.frame;
  __isset = other50.__isset;
}
Exhibit& Exhibit::operator=(const Exhibit& other51) {
  name = other51.name;
  frame = other51.frame;
  __isset = other51.__isset;
  return *this;
}
void Exhibit::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Exhibit(";
  out << "name=" << to_string(name);
  out << ", " << "frame="; (__isset.frame ? (out << to_string(frame)) : (out << "<null>"));
  out << ")";
}


ExhibitsResponse::~ExhibitsResponse() throw() {
}


void ExhibitsResponse::__set_version(const int32_t val) {
  this->version = val;
}

void ExhibitsResponse::__set_exhibits(const std::map<int32_t, Exhibit> & val) {
  this->exhibits = val;
}

uint32_t ExhibitsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->exhibits.clear();
            uint32_t _size52;
            ::apache::thrift::protocol::TType _ktype53;
            ::apache::thrift::protocol::TType _vtype54;
            xfer += iprot->readMapBegin(_ktype53, _vtype54, _size52);
            uint32_t _i56;
            for (_i56 = 0; _i56 < _size52; ++_i56)
            {
              int32_t _key57;
              xfer += iprot->readI32(_key57);
              Exhibit& _val58 = this->exhibits[_key57];
              xfer += _val58.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.exhibits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ExhibitsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ExhibitsResponse");

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("exhibits", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->exhibits.size()));
    std::map<int32_t, Exhibit> ::const_iterator _iter59;
    for (_iter59 = this->exhibits.begin(); _iter59 != this->exhibits.end(); ++_iter59)
    {
      xfer += oprot->writeI32(_iter59->first);
      xfer += _iter59->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ExhibitsResponse &a, ExhibitsResponse &b) {
  using ::std::swap;
  swap(a.version, b.version);
  swap(a.exhibits, b.exhibits);
  swap(a.__isset, b.__isset);
}

ExhibitsResponse::ExhibitsResponse(const ExhibitsResponse& other60) {
  version = other60.version;
  exhibits = other60.exhibits;
  __isset = other60.__isset;
}
ExhibitsResponse& ExhibitsResponse::operator=(const ExhibitsResponse& other61) {
  version = other61.version;
  exhibits = other61.exhibits;
  __isset = other61.__isset;
  return *this;
}
void ExhibitsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ExhibitsResponse(";
  out << "version=" << to_string(version);
  out << ", " << "exhibits=" << to_string(exhibits);
  out << ")";
}


RawReportEvent::~RawReportEvent() throw() {
}


void RawReportEvent::__set_exhibitId(const int32_t val) {
  this->exhibitId = val;
__isset.exhibitId = true;
}

void RawReportEvent::__set_durationInSecs(const int32_t val) {
  this->durationInSecs = val;
}

void RawReportEvent::__set_actions(const std::vector<int32_t> & val) {
  this->actions = val;
}

uint32_t RawReportEvent::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->exhibitId);
          this->__isset.exhibitId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->durationInSecs);
          this->__isset.durationInSecs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->actions.clear();
            uint32_t _size62;
            ::apache::thrift::protocol::TType _etype65;
            xfer += iprot->readListBegin(_etype65, _size62);
            this->actions.resize(_size62);
            uint32_t _i66;
            for (_i66 = 0; _i66 < _size62; ++_i66)
            {
              xfer += iprot->readI32(this->actions[_i66]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.actions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RawReportEvent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RawReportEvent");

  if (this->__isset.exhibitId) {
    xfer += oprot->writeFieldBegin("exhibitId", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->exhibitId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("durationInSecs", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->durationInSecs);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("actions", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->actions.size()));
    std::vector<int32_t> ::const_iterator _iter67;
    for (_iter67 = this->actions.begin(); _iter67 != this->actions.end(); ++_iter67)
    {
      xfer += oprot->writeI32((*_iter67));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RawReportEvent &a, RawReportEvent &b) {
  using ::std::swap;
  swap(a.exhibitId, b.exhibitId);
  swap(a.durationInSecs, b.durationInSecs);
  swap(a.actions, b.actions);
  swap(a.__isset, b.__isset);
}

RawReportEvent::RawReportEvent(const RawReportEvent& other68) {
  exhibitId = other68.exhibitId;
  durationInSecs = other68.durationInSecs;
  actions = other68.actions;
  __isset = other68.__isset;
}
RawReportEvent& RawReportEvent::operator=(const RawReportEvent& other69) {
  exhibitId = other69.exhibitId;
  durationInSecs = other69.durationInSecs;
  actions = other69.actions;
  __isset = other69.__isset;
  return *this;
}
void RawReportEvent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RawReportEvent(";
  out << "exhibitId="; (__isset.exhibitId ? (out << to_string(exhibitId)) : (out << "<null>"));
  out << ", " << "durationInSecs=" << to_string(durationInSecs);
  out << ", " << "actions=" << to_string(actions);
  out << ")";
}


RawReport::~RawReport() throw() {
}


void RawReport::__set_reportId(const int32_t val) {
  this->reportId = val;
}

void RawReport::__set_history(const std::vector<RawReportEvent> & val) {
  this->history = val;
}

uint32_t RawReport::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->reportId);
          this->__isset.reportId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->history.clear();
            uint32_t _size70;
            ::apache::thrift::protocol::TType _etype73;
            xfer += iprot->readListBegin(_etype73, _size70);
            this->history.resize(_size70);
            uint32_t _i74;
            for (_i74 = 0; _i74 < _size70; ++_i74)
            {
              xfer += this->history[_i74].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.history = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RawReport::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RawReport");

  xfer += oprot->writeFieldBegin("reportId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->reportId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("history", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->history.size()));
    std::vector<RawReportEvent> ::const_iterator _iter75;
    for (_iter75 = this->history.begin(); _iter75 != this->history.end(); ++_iter75)
    {
      xfer += (*_iter75).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RawReport &a, RawReport &b) {
  using ::std::swap;
  swap(a.reportId, b.reportId);
  swap(a.history, b.history);
  swap(a.__isset, b.__isset);
}

RawReport::RawReport(const RawReport& other76) {
  reportId = other76.reportId;
  history = other76.history;
  __isset = other76.__isset;
}
RawReport& RawReport::operator=(const RawReport& other77) {
  reportId = other77.reportId;
  history = other77.history;
  __isset = other77.__isset;
  return *this;
}
void RawReport::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RawReport(";
  out << "reportId=" << to_string(reportId);
  out << ", " << "history=" << to_string(history);
  out << ")";
}

} // namespace
